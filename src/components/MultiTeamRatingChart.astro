---
// src/components/MultiTeamRatingChart.astro
/* Props:
   - slugs?: string[]  // optional explicit team slugs to compare
*/
import { getCollection } from "astro:content";
import settings from "../config/settings";
import ChartJsScript from "./ChartJsScript.astro";

const { slugs = [] } = Astro.props as { slugs?: string[] };

const norm = (s?: string) => (s ?? "").toLowerCase().replace(/[^a-z0-9]/g, "");

// Load all teams
const teamEntries = await getCollection("teams");
const teams = teamEntries.map((t) => t.data);

// Load rating histories (support flat AND nested dirs)
const mods = import.meta.glob(
  ["../data/mhr-history/*.json", "../data/mhr-history/*/*.json"],
  { eager: true }
);

// Helper: get history by slug from either flat or nested path
function getHistForSlug(slug: string): any[] {
  const flat = mods[`../data/mhr-history/${slug}.json`] as any;
  if (flat?.default) return flat.default as any[];
  if (Array.isArray(flat)) return flat as any[];

  // try nested folders (find first key that ends with /<slug>.json)
  for (const [k, v] of Object.entries(mods)) {
    if (k.endsWith(`/${slug}.json`)) {
      const arr = (v as any)?.default ?? v;
      return Array.isArray(arr) ? arr as any[] : [];
    }
  }
  return [];
}

function isGoodNum(n: unknown) {
  return typeof n === "number" && Number.isFinite(n) && n > 0;
}

function latestNonZeroHistoryRating(hist: Array<{ date?: string; rating?: number }>) {
  for (let i = hist.length - 1; i >= 0; i--) {
    const r = hist[i]?.rating;
    if (isGoodNum(r)) return r as number;
  }
  return undefined;
}

// Pick teams to include
let picked = slugs.length
  ? teams.filter((t) => slugs.includes(t.slug))
  : teams.filter(
      (t) => norm(t.league) === norm(settings.leagueName) &&
             norm(t.division) === norm(settings.divisionName)
    );

// Compute an effective rating for sorting/eligibility
const withEff = picked.map((t) => {
  const hist = getHistForSlug(t.slug);
  const eff = latestNonZeroHistoryRating(hist) ?? (isGoodNum(t.rating) ? t.rating : undefined);
  return { team: t, hist, eff };
});

// Keep teams that actually have a usable rating
const usable = withEff.filter((x) => isGoodNum(x.eff));

// Sort by effective rating desc; include ALL (no .slice(0,4))
usable.sort((a, b) => (b.eff! - a.eff!));

// Build shared label axis (union of all dates that have any >0 rating)
const labelSet = new Set<string>();
for (const x of usable) {
  for (const p of x.hist) {
    if (p?.date && isGoodNum(p?.rating)) labelSet.add(String(p.date));
  }
}
const labels: string[] = Array.from(labelSet).sort();

// Build datasets aligned to labels; null where no point or <=0
const datasets = usable.map(({ team, hist }) => {
  const data = labels.map((d) => {
    const hit = hist.find((h) => h.date === d);
    return isGoodNum(hit?.rating) ? Number(hit.rating) : null;
  });
  const allEmpty = data.every((v) => v == null);
  return {
    label: team.name,
    data,
    hidden: allEmpty, // hide if nothing to show
  };
});

// Unique ids so multiple charts can coexist
const chartId = `multi-team-${Math.random().toString(36).slice(2)}`;
const dataId = `${chartId}-data`;
---

<div class="bg-gray-900 rounded-lg p-4 border border-red-600">
  <h2 class="text-lg font-semibold text-red-400 mb-2">Rating Comparison</h2>
  <canvas id={chartId} height="140"></canvas>

  <!-- JSON payload for the renderer -->
  <script
    id={dataId}
    type="application/json"
    data-chart="multi"
    data-target={chartId}
    set:html={JSON.stringify({ labels, datasets })}
  />
</div>

<!-- Ensure Chart.js (UMD) is available once globally -->
<ChartJsScript />

<!-- Render when Chart.js is ready -->
<script define:vars={{ dataId, chartId }}>
  (function () {
    const __DATA_ID__ = dataId;
    const __CANVAS_ID__ = chartId;

    function ensureChart() {
      if (window.Chart) return Promise.resolve();
      if (window.__chartReady) return window.__chartReady;
      return new Promise(function (res) {
        var i = setInterval(function () {
          if (window.Chart) { clearInterval(i); res(); }
        }, 20);
      });
    }

    function palette(i, a) {
      var hues = [0, 18, 200, 145, 260, 35, 310, 90];
      var h = hues[i % hues.length];
      return "hsla(" + h + ", 85%, 60%, " + a + ")";
    }

    function renderOne(node) {
      try {
        var canvas = document.getElementById(__CANVAS_ID__);
        if (!canvas) return;

        var raw = node.textContent || "{}";
        var payload = JSON.parse(raw);
        var labels = payload.labels || [];
        var datasets = (payload.datasets || []).map(function (d, idx) {
          var stroke = idx === 0 ? "#ef4444" : palette(idx, 1);
          var fill   = idx === 0 ? "rgba(239,68,68,0.25)" : palette(idx, 0.2);
          var allZeroOrNull = Array.isArray(d.data) && d.data.every(function (v) { return v === 0 || v == null; });
          return Object.assign({}, d, {
            spanGaps: true,
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 2,
            borderColor: allZeroOrNull ? "rgba(239,68,68,0.35)" : stroke,
            backgroundColor: allZeroOrNull ? "rgba(239,68,68,0.08)" : fill,
            borderDash: allZeroOrNull ? [4,4] : undefined
          });
        });

        var ctx = canvas.getContext("2d");
        // eslint-disable-next-line no-undef, no-new
        new Chart(ctx, {
          type: "line",
          data: { labels: labels, datasets: datasets },
          options: {
            responsive: true,
            interaction: { mode: "nearest", intersect: false },
            plugins: {
              legend: { labels: { color: "#ffffff" } },
              title: { display: false },
              tooltip: { enabled: true }
            },
            scales: {
              x: {
                ticks: { color: "#d1d5db", autoSkip: true, maxTicksLimit: 10 },
                grid: { color: "rgba(255,255,255,0.08)" }
              },
              y: {
                ticks: { color: "#d1d5db" },
                grid: { color: "rgba(255,255,255,0.08)" }
              }
            }
          }
        });
      } catch (err) {
        console.warn("[MultiTeamRatingChart] render error:", err);
      }
    }

    ensureChart().then(function () {
      var node = document.getElementById(__DATA_ID__);
      if (node) renderOne(node);
    });
  })();
</script>
