---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import settings from "../config/settings";
import { winProb } from "../lib/probability";
import WinProbBadge from "../components/WinProbBadge.astro";

/* ---------------------------------------------
   Load data: manual games + auto-generated JSON
---------------------------------------------- */
const manualGames = (await getCollection("games")).map((g) => g.data);
const teamEntries = await getCollection("teams");
const teams = teamEntries.map((t) => t.data);

// Teams by slug for O(1) lookups
const teamBySlug = new Map(teams.map((t) => [t.slug, t]));
const myTeam = teamBySlug.get(settings.teamSlug);

// Auto (generated) for your team
const autoMods = import.meta.glob("../data/auto-schedule/*.json", { eager: true });
const autoGames =
  autoMods[`../data/auto-schedule/${settings.teamSlug}.json`]?.default ?? [];

// Optional overrides map: { [sourceId]: "opponent-slug" }
let opponentOverrides: Record<string, string> = {};
try {
  // Create this file if you need hard mappings; safe if missing.
  opponentOverrides = (await import("../data/opponent-overrides.json")).default ?? {};
} catch {
  opponentOverrides = {};
}

/* ---------------------------------------------
   Merge & de-duplicate
---------------------------------------------- */
const key = (g: any) =>
  [g.date, g.time ?? "", (g.opponent ?? g.opponentSlug ?? "").toLowerCase()].join("|");

const mergedMap = new Map<string, any>();
[...autoGames, ...manualGames].forEach((g) => mergedMap.set(key(g), g));
const games = [...mergedMap.values()].sort((a, b) =>
  (a.date + (a.time ?? "")).localeCompare(b.date + (b.time ?? ""))
);

/* ---------------------------------------------
   Opponent resolution helpers
---------------------------------------------- */
function norm(s = "") {
  return s.toLowerCase().trim();
}
function normAlnum(s = "") {
  return norm(s).replace(/[^a-z0-9]/g, "");
}
function slugify(s = "") {
  return norm(s).replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
}

/** Normalize common abbreviations / spelling variants */
function normalizeNamesForTokens(s = "") {
  let txt = norm(s);

  // St./STP → "saint peters" (Crossbar often uses STP)
  txt = txt.replace(/\bstp\b/g, "saint peters");
  txt = txt.replace(/\bst\.?\b/g, "saint ");

  // "u 12" / "12 u" → "12u"
  txt = txt.replace(/\b(\d+)\s*u\b/g, "$1u");
  txt = txt.replace(/\bu\s*(\d+)\b/g, "$1u");
  txt = txt.replace(/\b(\d+)\s*under\b/g, "$1u");

  // Collapse extra spaces
  txt = txt.replace(/\s+/g, " ").trim();

  return txt;
}

function extractTokens(s = "") {
  const cleaned = normalizeNamesForTokens(s);

  // Pull useful bits
  const age = (cleaned.match(/\b(\d{1,2})u\b/) || [])[1] || null;
  const levelToken =
    (cleaned.match(/\b(a|b|c)\s*([123])\b/) ||
      cleaned.match(/\b(a|b|c)([123])\b/) ||
      (cleaned.match(/\b(house|rec)\b/) as any) ||
      [])[0] || null;

  // Tokenize on non-alnum
  const tokens = cleaned
    .split(/[^a-z0-9]+/g)
    .filter(Boolean)
    .filter((w) => w.length > 1);

  return {
    raw: s,
    cleaned,
    age, // "12"
    level: levelToken ? levelToken.replace(/\s+/g, "") : null, // "a2" / "b1" / "house"
    alnum: normAlnum(s),
    slug: slugify(s),
    tokens: new Set(tokens),
  };
}

function teamIndex(t: any) {
  const nameTok = extractTokens(t.name || "");
  const slugTok = extractTokens(t.slug || "");
  const aliases = Array.isArray(t.aliases) ? t.aliases : [];
  const aliasToks = aliases.map(extractTokens);

  // Try to infer age/level from either name or slug
  const age = nameTok.age || slugTok.age || null;
  const level = nameTok.level || slugTok.level || null;

  // Org tokens (e.g., "kirkwood", "saint", "peters")
  const orgTokens = new Set(
    [...nameTok.tokens, ...slugTok.tokens].filter(
      (w) => !/^(12u|10u|14u|a1|a2|a3|b1|b2|b3|house|rec)$/.test(w)
    )
  );

  return { t, nameTok, slugTok, aliasToks, age, level, orgTokens };
}

const indexedTeams = teams.map(teamIndex);

/** Score a team against a raw opponent string */
function scoreTeamMatch(raw: string) {
  const q = extractTokens(raw);
  let best = { score: -Infinity, hit: null as any };

  for (const entry of indexedTeams) {
    const { t, nameTok, slugTok, aliasToks, age, level, orgTokens } = entry;

    let s = 0;

    // Strong exact-ish signals
    if (q.slug && q.slug === slugTok.slug) s += 100;
    if (t.slug && q.cleaned === slugify(t.slug)) s += 95;
    if (q.alnum && q.alnum === nameTok.alnum) s += 92;
    if (q.alnum && q.alnum === slugTok.alnum) s += 90;

    // Alias exacts
    for (const a of aliasToks) {
      if (q.alnum && q.alnum === a.alnum) s += 88;
      if (q.slug && q.slug === a.slug) s += 88;
    }

    // Token overlap (org/city/nickname words)
    const overlap = [...q.tokens].filter(
      (w) => nameTok.tokens.has(w) || slugTok.tokens.has(w) || orgTokens.has(w)
    ).length;
    s += Math.min(30, overlap * 6); // up to +30

    // Age weight
    if (q.age && age && q.age === age) s += 20;
    else if (q.age && age && q.age !== age) s -= 25;

    // Level/flight weight (A1/A2/B/C/House/etc.)
    if (q.level && level && q.level === level) s += 35;
    else if (q.level && level && q.level !== level) s -= 40;
    if (q.level && !level) s -= 15;

    // Keep best
    if (s > best.score) best = { score: s, hit: t };
  }

  // Only accept confident matches; adjust as needed
  return best.score >= 60 ? best.hit : null;
}

/** Main opponent resolver */
function findOpponent(g: any) {
  // 0) SourceID → override slug (for Crossbar ICS ambiguity like "Kirkwood"/"STP")
  if (g.sourceId) {
    const forcedSlug = opponentOverrides[g.sourceId];
    if (forcedSlug && teamBySlug.has(forcedSlug)) return teamBySlug.get(forcedSlug);
  }

  // 1) Explicit slug on the row
  if (g.opponentSlug && teamBySlug.has(g.opponentSlug)) return teamBySlug.get(g.opponentSlug);

  // 2) Literal lookup vs team slugs
  const raw = (g.opponent || "").trim();
  if (!raw) return null;
  if (teamBySlug.has(raw)) return teamBySlug.get(raw);

  // 3) Slugify the raw label
  const guess = slugify(raw);
  if (teamBySlug.has(guess)) return teamBySlug.get(guess);

  // 4) Token/age/level-aware best-effort match
  return scoreTeamMatch(raw);
}

/* ---------------------------------------------
   Time-zone aware display helpers
---------------------------------------------- */
const TZ = settings.timeZone || "America/Chicago";

function fmtDate(d: string | number | Date) {
  return new Date(d).toLocaleDateString("en-US", { timeZone: TZ });
}
function fmtTime(d: string | number | Date) {
  return new Date(d).toLocaleTimeString("en-US", {
    timeZone: TZ,
    hour: "2-digit",
    minute: "2-digit",
  });
}

/** Build a Date assuming incoming date+time are in UTC (ICS-derived flat fields) */
function dateFromUtcParts(dateStr?: string, timeStr?: string) {
  if (!dateStr || !timeStr) return null;
  const hhmm = /^\d{2}:\d{2}$/.test(timeStr) ? `${timeStr}:00` : timeStr;
  const iso = `${dateStr}T${hhmm}Z`;
  const d = new Date(iso);
  return isNaN(d.getTime()) ? null : d;
}

/** All-day-ish check for ICS rows with midnight times */
function isAllDay(g: any) {
  if (g.source !== "ics") return false;
  return (g.time === "00:00" || g.time === "00:00:00") && !g.start;
}

/** Prefer ISO start; else convert UTC clock to local for ICS rows; else show raw */
function displayDate(g: any) {
  if (g.start) return fmtDate(g.start);
  if (g.source === "ics") {
    const d = dateFromUtcParts(g.date, g.time);
    if (d) return fmtDate(d);
  }
  return g.date;
}
function displayTime(g: any) {
  if (g.start) return fmtTime(g.start);
  if (g.source === "ics") {
    if (isAllDay(g)) return "—";
    const d = dateFromUtcParts(g.date, g.time);
    if (d) return fmtTime(d);
  }
  if (!g.time || g.time === "00:00" || g.time === "00:00:00") return "—";
  return g.time;
}
---

<BaseLayout
  title={`Schedule – ${settings.portalName}`}
  description={`Merged schedule for ${settings.teamName}: manual games + ICS imports, de-duplicated and shown in ${settings.timeZone || "America/Chicago"}. Includes opponent links and win probability when ratings exist.`}
>
  <h1 class="text-2xl font-bold text-red-500 mb-4">Schedule</h1>
  {games.length === 0 ? (
    <p class="text-gray-300">No games found.</p>
  ) : (
    <div class="overflow-x-auto rounded-lg border border-red-600">
      <table class="min-w-full text-sm">
        <thead class="bg-red-600 text-white uppercase text-xs">
          <tr>
            <th class="px-3 py-2 text-left">Date</th>
            <th class="px-3 py-2 text-left">Time</th>
            <th class="px-3 py-2 text-left">Opponent</th>
            <th class="px-3 py-2 text-left">H/A</th>
            <th class="px-3 py-2 text-left">Venue</th>
            <th class="px-3 py-2 text-left">Win %</th>
            <th class="px-3 py-2 text-left">Preview</th>
            <th class="px-3 py-2 text-left">Source</th>
          </tr>
        </thead>
        <tbody class="bg-gray-900 divide-y divide-gray-700">
          {games.map((g) => {
            const opp = findOpponent(g);
            const p =
              myTeam &&
              opp &&
              typeof myTeam.rating === "number" &&
              typeof opp.rating === "number"
                ? winProb(myTeam.rating, opp.rating)
                : undefined;

            return (
              <tr class="hover:bg-gray-800">
                <td class="px-3 py-2">{displayDate(g)}</td>
                <td class="px-3 py-2">{displayTime(g)}</td>
                <td class="px-3 py-2">
                  {opp ? (
                    <a class="underline hover:text-red-400" href={`/teams/${opp.slug}/`}>
                      {opp.name}
                    </a>
                  ) : (
                    g.opponent ?? g.opponentSlug ?? "TBD"
                  )}
                </td>
                <td class="px-3 py-2">{g.homeAway ?? "Neutral"}</td>
                <td class="px-3 py-2">{g.venue ?? "—"}</td>
                <td class="px-3 py-2">
                  <WinProbBadge p={p} />
                </td>
                <td class="px-3 py-2">
                  {opp ? (
                    <a class="underline hover:text-red-400" href={`/matchups/${opp.slug}/`}>
                      Matchup
                    </a>
                  ) : (
                    "—"
                  )}
                </td>
                <td class="px-3 py-2 uppercase text-xs text-gray-400">
                  {g.source ?? "manual"}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  )}
</BaseLayout>
